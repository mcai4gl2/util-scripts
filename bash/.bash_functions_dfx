dfx() {
    local want_json=0
    local threshold_yellow=70
    local threshold_red=90
    local args=()

    # Parse flags
    while [ $# -gt 0 ]; do
        case "$1" in
            --json)
                want_json=1
                ;;
            --yellow=*)
                threshold_yellow="${1#*=}"
                ;;
            --red=*)
                threshold_red="${1#*=}"
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done

    if [ "$want_json" -eq 1 ]; then
        # JSON output (unchanged logic)
        echo "["
        local first=1
        # -P for POSIX one-line per FS. Mountpoint with spaces is safe with read's last field.
        df -hP "${args[@]}" | tail -n +2 | while read -r fs size used avail usep mount; do
            [ -z "$fs" ] && continue
            local use=${usep%%%}

            esc_fs=$(printf '%s' "$fs" | sed 's/\\/\\\\/g; s/"/\\"/g')
            esc_mount=$(printf '%s' "$mount" | sed 's/\\/\\\\/g; s/"/\\"/g')

            if [ $first -eq 0 ]; then
                echo ","
            fi
            first=0
            cat <<EOF
  {
    "filesystem": "$esc_fs",
    "size": "$size",
    "used": "$used",
    "available": "$avail",
    "use_percent": $use,
    "mounted_on": "$esc_mount"
  }
EOF
        done
        echo "]"
        return 0
    fi

    # ----- Human-readable, perfectly aligned and colorized -----

    # ANSI colors
    local RS="\033[0m"
    local GR="\033[0;32m"
    local YE="\033[0;33m"
    local RD="\033[0;31m"

    # Build a clean TSV (tab-separated) without color, sort by numeric Use%
    # We keep the percent as a pure number in col 5 for sorting.
    {
        printf "Filesystem\tSize\tUsed\tAvail\tUse%%\tMounted on\n"
        df -hP "${args[@]}" | tail -n +2 | while read -r fs size used avail usep mount; do
            [ -z "$fs" ] && continue
            use=${usep%%%}
            # Tab-separated row: fs  size  used  avail  use(plain number)  mount(with spaces ok)
            printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$fs" "$size" "$used" "$avail" "$use" "$mount"
        done | sort -k5,5nr
    } |
    # Align by tabs
    column -s $'\t' -t |
    # Colorize the Use% column *after* alignment so spacing stays intact.
    awk -v y="$threshold_yellow" -v r="$threshold_red" \
        -v RS="$RS" -v GR="$GR" -v YE="$YE" -v RD="$RD" '
        BEGIN { OFS="  " }  # column already aligned using spaces; keep spacing
        NR==1 {
            print; next
        }
        {
            # Find the 5th column (Use%)
            # Split on runs of at least two spaces to be robust to spacing between columns.
            n = split($0, cols, /  +/)
            # cols[5] should look like "NN"
            # But after column itâ€™s "NN" (no %), because we printed NN; add % for display.
            use = cols[5] + 0
            color = (use>=r)? RD : (use>=y? YE : GR)
            cols[5] = color use "%" RS

            # Reconstruct line with two spaces between columns
            out = cols[1]
            for (i=2; i<=n; i++) out = out "  " cols[i]
            print out
        }'
}
